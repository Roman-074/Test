
ls -a - настройка отображения скрытой папки .git
ls - вывод в командную строку содержимого дериктории
clear - очистка окна консоли

git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

git init - инициализация проекта (создание репозитория) в конкретной папке
git add * - индексируем все новые файлы
git add . - индексируем файлы текущей директории
gitk - вызов графического интерфейса отображения истории коммитов

git log - просмотр истории коммитов в консоли
git log --pretty=oneline - вывод коммитов в одну строку (если коммитов много, то выведутся не все)
git log --max-count=3 - вывод только последних трех коммитов
git log --all - вывод всех коммитов
git log --author="имя автора" - вывод коммитов определенного автора
git log --pretty=format:" %h - %s : %ad [ %an ] " --date=short
%h - короткая версия хэша
%s - комментарий коммита
%ad - дата, когда был выведен коммит
%an - имя автора коммита
--date=short - короткая запись даты для простоты восприятия

git checkout [хэш коммита] -  перемещение просмотра итории к данному коммиту
(временный откат к определенному коммиту, который становится последним в данной ветке)

git reset HEAD [имя файла] -  отменяет изменения, перенося ссылку на ветку назад, на более старый коммит (отмена индексации)
// git reset HEAD~1 - отмена последней индексации (возврат на один коммит назад)
HEAD всегда указывает на последний коммит локального дерева
вместо HEAD можно написать любой из коммитов, указав его хэш, и отменить все изменения после этого коммита

git reset используется для локальных репозиториев. Если же мы хотим поделиться отменой коммита с остальной командой в удаленном репозитории, 
то нужно использовать: 
git revert HEAD - при это создается новый коммит с изменениями, полностью противоположными в предыдущем

git revert HEAD --no-edit - отмена коммита (удаление последнего коммита) могут возникать конфликты 
git revert --abort  -  отмена попытки отката (при отмене отката пропадает и ошибка, которая могла возникнуть при откате)

Последовательность действий для отмены изменений: git reset [хэш коммита] >>> git checkout [хэш коммита]
Сначала снимается индексация файла, затем идет возврат к посленему коммиту

Если конфликт возникает во время revert, то будет высвечиваться команда git revert --continue
Основной посыл при исправлении конфликтов - привести файлы к тому виду, который нам нужен, и сообщить git'у что конфликт исправлен

git checkout -b [имя ветки] - создание новой ветки 

git merge [имя ветки] - слияние текущей ветки с указанной в команде в порядке последовательности истории коммитов //1234
git rebase [имя ветки] - слияние указанной в команде ветки поверх текущей (стек) //2413
***rebase рекомендуется использовать только для редактирования своих локальных веток
***merge - для работы в общей веткке с другими разработчиками

При слиянии веток также может может возникнуть конфликт - в данном случае нужно либо отменить merge, либо привести файл к нужно виду и сделать коммит

git clone [ссылка] - копирование проекта с удаленного репозитория в текущую директорию
git remote add origin [ссылка] - доабавление удаленного репозитория в наш локальный

git push -u origin master - загрузка изменений на удаленный репозиторий с локального
ключевое слово origin указывает на удаленный репозиторий
git push -u origin <любая другая ветка>

git pull origin [имя ветки] - подтягивание изменений с удаленного репозитория в локальный
git pull --rebase origin master - вытягивание изменений из удаленного репозитория, а затем поверх этих изменений наложение локальных изменений
данная команда позволяет минимизировать вероятность конфликта изменений


git stash - "припрятывание"(временная отмена с сохранением текущего прогресса в отдельной "корзине") последних изменений в локальном репозитории 
(например чтобы вытянуть изменения с удаленного и потом вернуть локальные поверх)

git stash pop - возврат последнего stash'a + его удаление из stash list

git stash list - список спрятанных изменений в локальном репозитории
git stash show - просмотр последнего изменения в stash list

git stash apply - применение последнего stasha'a без его удаления из stash list
git stash drop - удаление последнего добавленного stash'a

git stash clear - очистка stash list'a (следует быть аккуратным, т.к. прогресс изменений удаляется безвозвратно)


git remote - просмотр списка удаленных серверов, с которыми можно работать
git remote -v - просмотр списка удаленных репозиториев, с которыми ведется работа в данный момент


^ - оператор каретки
Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита

Так что master^ означает "первый родитель ветки master".
master^^ означает прародитель (родитель родителя) master //Сильно проще, чем поиск и указание хеша
Можно также использовать HEAD как относительную ссылку   // Мы можем путешествовать во времени при помощи HEAD^ (откатывать коммит за коммитом)

ex: git checkout HEAD^^

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз),
так что Git поддерживает также оператор тильда (~)
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти

ex: git checkout HEAD~98

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. 
Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

git branch -f master HEAD~3

Переместит (принудительно) ветку master на три родителя назад от HEAD


git cherry-pick  <Commit1> <Commit2> <...> 
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD)
Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)
Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях!
Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase
Всё, что нужно для интерактивного rebase - это опция -i
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). 
Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему

__________________________________________________________________________________________________________________________________________________________


Игра-самоучитель
https://learngitbranching.js.org/?NODEMO

git commit 
	--amend
	-a
	--all
	-am
	-m




git pull
	-rebase
git fakeTeamwork
git clone
git remote
	-v
git fetch
git branch
	-d
	-D
	-f 	// принудительное перемещение ветки  ex: git branch -f master [хэш]
	--force
	-a
	-r
	-u
	--contains
git add
git reset
	--hard
	--soft
git revert
git merge
	--no-ff
git rev-list
git log
git show
git rebase
	-i
	--solution-ordering
	--interactive-test
	--aboveAll
	-p
	--preserve-merges
git status
git checkout  	//	ex: git checkout HEAD^^
	-b
	-B
	-
git push
	--force
git describe
git tag
	-d